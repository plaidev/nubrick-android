/**
 * This file is generated automatically. Do not edit this file.
 */
package com.nativebrik.sdk.schema

import android.os.Build
import java.time.ZonedDateTime
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.jsonPrimitive
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonArray


/**
 * This file is generated automatically. Do not edit this file.
 */

internal typealias ID = String
internal typealias DateTime = ZonedDateTime

internal class StringDecoder {
	companion object {
		fun decode(element: JsonElement?): String? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return element.jsonPrimitive.content
		}
	}
}

internal class StringEncoder {
	companion object {
		fun encode(data: String?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return JsonPrimitive(data)
		}
	}
}

internal class IntDecoder {
	companion object {
		fun decode(element: JsonElement?): Int? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (element.jsonPrimitive.isString) {
				return null
			}
			return try {
				return element.jsonPrimitive.content.toInt()
			} catch (e: Exception) {
				return null
			}
		}
	}
}

internal class IntEncoder {
	companion object {
		fun encode(data: Int?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return JsonPrimitive(data)
		}
	}
}

internal class FloatDecoder {
	companion object {
		fun decode(element: JsonElement?): Float? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (element.jsonPrimitive.isString) {
				return null
			}
			return try {
				return element.jsonPrimitive.content.toFloat()
			} catch (e: Exception) {
				return null
			}
		}
	}
}

internal class FloatEncoder {
	companion object {
		fun encode(data: Float?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return JsonPrimitive(data)
		}
	}
}

internal class BooleanDecoder {
	companion object {
		fun decode(element: JsonElement?): Boolean? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (element.jsonPrimitive.isString) {
				return null
			}
			return try {
				return element.jsonPrimitive.content.toBoolean()
			} catch (e: Exception) {
				return null
			}
		}
	}
}

internal class BooleanEncoder {
	companion object {
		fun encode(data: Boolean?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return JsonPrimitive(data)
		}
	}
}

internal class ListDecoder {
	companion object {
		fun <T> decode(element: JsonElement?, decoder: (element: JsonElement?) -> T?): List<T>? {
			if (element == null) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (element !is JsonArray) {
				return null
			}
			val list = mutableListOf<T>()
			val iterator = element.jsonArray.iterator()
			while (iterator.hasNext()) {
				val item = iterator.next()
				val decoded = decoder(item) ?: continue
				list.add(decoded)
			}
			return list
		}
	}
}

internal class ListEncoder {
	companion object {
		fun <T> encode(data: List<T>?, encoder: (data: T?) -> JsonElement?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			val list = mutableListOf<JsonElement>()
			for (item in data) {
				val encoded = encoder(item) ?: continue
				list.add(encoded)
			}
			return JsonArray(list)
		}
	}
}

internal class DateTimeDecoder {
	companion object {
		fun decode(element: JsonElement?): ZonedDateTime? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return try {
				ZonedDateTime.parse(element.jsonPrimitive.content)
			} catch (e: Exception) {
				return null
			}
		}
	}
}

internal class DateTimeEncoder {
	companion object {
		fun encode(data: ZonedDateTime?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return JsonPrimitive(data.toString())
		}
	}
}


internal enum class AlignItems {
	START,
	CENTER,
	END,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): AlignItems? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"START" -> START
				"CENTER" -> CENTER
				"END" -> END
				else -> UNKNOWN
			}
		}

		fun encode(data: AlignItems?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				START -> JsonPrimitive("START")
				CENTER -> JsonPrimitive("CENTER")
				END -> JsonPrimitive("END")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class ApiHttpHeader (
	val name: String? = null,
	val value: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ApiHttpHeader? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ApiHttpHeader(
				name = StringDecoder.decode(element.jsonObject["name"]),
				value = StringDecoder.decode(element.jsonObject["value"]),
			)
		}

		fun encode(data: ApiHttpHeader?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ApiHttpHeader")
			data.name?.let { value ->
				StringEncoder.encode(value)?.let { map["name"] = it }
			}
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class ApiHttpRequest (
	val url: String? = null,
	val method: ApiHttpRequestMethod? = null,
	val headers: List<ApiHttpHeader>? = null,
	val body: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ApiHttpRequest? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ApiHttpRequest(
				url = StringDecoder.decode(element.jsonObject["url"]),
				method = ApiHttpRequestMethod.decode(element.jsonObject["method"]),
				headers = ListDecoder.decode(element.jsonObject["headers"]) { element: JsonElement? ->
				ApiHttpHeader.decode(element)
			},
				body = StringDecoder.decode(element.jsonObject["body"]),
			)
		}

		fun encode(data: ApiHttpRequest?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ApiHttpRequest")
			data.url?.let { value ->
				StringEncoder.encode(value)?.let { map["url"] = it }
			}
			data.method?.let { value ->
				ApiHttpRequestMethod.encode(value)?.let { map["method"] = it }
			}
			data.headers?.let { value ->
				ListEncoder.encode(value) { item ->
					ApiHttpHeader.encode(item)
				}?.let { map["headers"] = it }
			}
			data.body?.let { value ->
				StringEncoder.encode(value)?.let { map["body"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class ApiHttpRequestMethod {
	GET,
	POST,
	PUT,
	DELETE,
	PATCH,
	HEAD,
	TRACE,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): ApiHttpRequestMethod? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"GET" -> GET
				"POST" -> POST
				"PUT" -> PUT
				"DELETE" -> DELETE
				"PATCH" -> PATCH
				"HEAD" -> HEAD
				"TRACE" -> TRACE
				else -> UNKNOWN
			}
		}

		fun encode(data: ApiHttpRequestMethod?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				GET -> JsonPrimitive("GET")
				POST -> JsonPrimitive("POST")
				PUT -> JsonPrimitive("PUT")
				DELETE -> JsonPrimitive("DELETE")
				PATCH -> JsonPrimitive("PATCH")
				HEAD -> JsonPrimitive("HEAD")
				TRACE -> JsonPrimitive("TRACE")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class ApiHttpResponseAssertion (
	val statusCodes: List<Int>? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ApiHttpResponseAssertion? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ApiHttpResponseAssertion(
				statusCodes = ListDecoder.decode(element.jsonObject["statusCodes"]) { element: JsonElement? ->
				IntDecoder.decode(element)
			},
			)
		}

		fun encode(data: ApiHttpResponseAssertion?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ApiHttpResponseAssertion")
			data.statusCodes?.let { value ->
				ListEncoder.encode(value) { item ->
					IntEncoder.encode(item)
				}?.let { map["statusCodes"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class BoxShadow (
	val color: Color? = null,
	val offsetX: Int? = null,
	val offsetY: Int? = null,
	val radius: Int? = null,
) {
	companion object {
		fun decode(element: JsonElement?): BoxShadow? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return BoxShadow(
				color = Color.decode(element.jsonObject["color"]),
				offsetX = IntDecoder.decode(element.jsonObject["offsetX"]),
				offsetY = IntDecoder.decode(element.jsonObject["offsetY"]),
				radius = IntDecoder.decode(element.jsonObject["radius"]),
			)
		}

		fun encode(data: BoxShadow?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("BoxShadow")
			data.color?.let { value ->
				Color.encode(value)?.let { map["color"] = it }
			}
			data.offsetX?.let { value ->
				IntEncoder.encode(value)?.let { map["offsetX"] = it }
			}
			data.offsetY?.let { value ->
				IntEncoder.encode(value)?.let { map["offsetY"] = it }
			}
			data.radius?.let { value ->
				IntEncoder.encode(value)?.let { map["radius"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class BuiltinUserProperty {
	userId,
	userRnd,
	languageCode,
	regionCode,
	currentTime,
	firstBootTime,
	lastBootTime,
	retentionPeriod,
	bootingTime,
	sdkVersion,
	osVersion,
	osName,
	appId,
	appVersion,
	cfBundleVersion,
	localYear,
	localMonth,
	localWeekday,
	localDay,
	localHour,
	localMinute,
	localSecond,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): BuiltinUserProperty? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"userId" -> userId
				"userRnd" -> userRnd
				"languageCode" -> languageCode
				"regionCode" -> regionCode
				"currentTime" -> currentTime
				"firstBootTime" -> firstBootTime
				"lastBootTime" -> lastBootTime
				"retentionPeriod" -> retentionPeriod
				"bootingTime" -> bootingTime
				"sdkVersion" -> sdkVersion
				"osVersion" -> osVersion
				"osName" -> osName
				"appId" -> appId
				"appVersion" -> appVersion
				"cfBundleVersion" -> cfBundleVersion
				"localYear" -> localYear
				"localMonth" -> localMonth
				"localWeekday" -> localWeekday
				"localDay" -> localDay
				"localHour" -> localHour
				"localMinute" -> localMinute
				"localSecond" -> localSecond
				else -> UNKNOWN
			}
		}

		fun encode(data: BuiltinUserProperty?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				userId -> JsonPrimitive("userId")
				userRnd -> JsonPrimitive("userRnd")
				languageCode -> JsonPrimitive("languageCode")
				regionCode -> JsonPrimitive("regionCode")
				currentTime -> JsonPrimitive("currentTime")
				firstBootTime -> JsonPrimitive("firstBootTime")
				lastBootTime -> JsonPrimitive("lastBootTime")
				retentionPeriod -> JsonPrimitive("retentionPeriod")
				bootingTime -> JsonPrimitive("bootingTime")
				sdkVersion -> JsonPrimitive("sdkVersion")
				osVersion -> JsonPrimitive("osVersion")
				osName -> JsonPrimitive("osName")
				appId -> JsonPrimitive("appId")
				appVersion -> JsonPrimitive("appVersion")
				cfBundleVersion -> JsonPrimitive("cfBundleVersion")
				localYear -> JsonPrimitive("localYear")
				localMonth -> JsonPrimitive("localMonth")
				localWeekday -> JsonPrimitive("localWeekday")
				localDay -> JsonPrimitive("localDay")
				localHour -> JsonPrimitive("localHour")
				localMinute -> JsonPrimitive("localMinute")
				localSecond -> JsonPrimitive("localSecond")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class CollectionKind {
	CAROUSEL,
	SCROLL,
	GRID,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): CollectionKind? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"CAROUSEL" -> CAROUSEL
				"SCROLL" -> SCROLL
				"GRID" -> GRID
				else -> UNKNOWN
			}
		}

		fun encode(data: CollectionKind?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				CAROUSEL -> JsonPrimitive("CAROUSEL")
				SCROLL -> JsonPrimitive("SCROLL")
				GRID -> JsonPrimitive("GRID")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class Color (
	val red: Float? = null,
	val green: Float? = null,
	val blue: Float? = null,
	val alpha: Float? = null,
) {
	companion object {
		fun decode(element: JsonElement?): Color? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return Color(
				red = FloatDecoder.decode(element.jsonObject["red"]),
				green = FloatDecoder.decode(element.jsonObject["green"]),
				blue = FloatDecoder.decode(element.jsonObject["blue"]),
				alpha = FloatDecoder.decode(element.jsonObject["alpha"]),
			)
		}

		fun encode(data: Color?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("Color")
			data.red?.let { value ->
				FloatEncoder.encode(value)?.let { map["red"] = it }
			}
			data.green?.let { value ->
				FloatEncoder.encode(value)?.let { map["green"] = it }
			}
			data.blue?.let { value ->
				FloatEncoder.encode(value)?.let { map["blue"] = it }
			}
			data.alpha?.let { value ->
				FloatEncoder.encode(value)?.let { map["alpha"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class ConditionOperator {
	Regex,
	Equal,
	NotEqual,
	GreaterThan,
	GreaterThanOrEqual,
	LessThan,
	LessThanOrEqual,
	In,
	NotIn,
	Between,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): ConditionOperator? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"Regex" -> Regex
				"Equal" -> Equal
				"NotEqual" -> NotEqual
				"GreaterThan" -> GreaterThan
				"GreaterThanOrEqual" -> GreaterThanOrEqual
				"LessThan" -> LessThan
				"LessThanOrEqual" -> LessThanOrEqual
				"In" -> In
				"NotIn" -> NotIn
				"Between" -> Between
				else -> UNKNOWN
			}
		}

		fun encode(data: ConditionOperator?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				Regex -> JsonPrimitive("Regex")
				Equal -> JsonPrimitive("Equal")
				NotEqual -> JsonPrimitive("NotEqual")
				GreaterThan -> JsonPrimitive("GreaterThan")
				GreaterThanOrEqual -> JsonPrimitive("GreaterThanOrEqual")
				LessThan -> JsonPrimitive("LessThan")
				LessThanOrEqual -> JsonPrimitive("LessThanOrEqual")
				In -> JsonPrimitive("In")
				NotIn -> JsonPrimitive("NotIn")
				Between -> JsonPrimitive("Between")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class ExperimentCondition (
	val property: String? = null,
	val asType: UserPropertyType? = null,
	val operator: String? = null,
	val value: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ExperimentCondition? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ExperimentCondition(
				property = StringDecoder.decode(element.jsonObject["property"]),
				asType = UserPropertyType.decode(element.jsonObject["asType"]),
				operator = StringDecoder.decode(element.jsonObject["operator"]),
				value = StringDecoder.decode(element.jsonObject["value"]),
			)
		}

		fun encode(data: ExperimentCondition?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ExperimentCondition")
			data.property?.let { value ->
				StringEncoder.encode(value)?.let { map["property"] = it }
			}
			data.asType?.let { value ->
				UserPropertyType.encode(value)?.let { map["asType"] = it }
			}
			data.operator?.let { value ->
				StringEncoder.encode(value)?.let { map["operator"] = it }
			}
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class ExperimentConfig (
	val id: ID? = null,
	val kind: ExperimentKind? = null,
	val distribution: List<ExperimentCondition>? = null,
	val baseline: ExperimentVariant? = null,
	val variants: List<ExperimentVariant>? = null,
	val seed: Int? = null,
	val frequency: ExperimentFrequency? = null,
	val startedAt: DateTime? = null,
	val endedAt: DateTime? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ExperimentConfig? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ExperimentConfig(
				id = StringDecoder.decode(element.jsonObject["id"]),
				kind = ExperimentKind.decode(element.jsonObject["kind"]),
				distribution = ListDecoder.decode(element.jsonObject["distribution"]) { element: JsonElement? ->
				ExperimentCondition.decode(element)
			},
				baseline = ExperimentVariant.decode(element.jsonObject["baseline"]),
				variants = ListDecoder.decode(element.jsonObject["variants"]) { element: JsonElement? ->
				ExperimentVariant.decode(element)
			},
				seed = IntDecoder.decode(element.jsonObject["seed"]),
				frequency = ExperimentFrequency.decode(element.jsonObject["frequency"]),
				startedAt = DateTimeDecoder.decode(element.jsonObject["startedAt"]),
				endedAt = DateTimeDecoder.decode(element.jsonObject["endedAt"]),
			)
		}

		fun encode(data: ExperimentConfig?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ExperimentConfig")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.kind?.let { value ->
				ExperimentKind.encode(value)?.let { map["kind"] = it }
			}
			data.distribution?.let { value ->
				ListEncoder.encode(value) { item ->
					ExperimentCondition.encode(item)
				}?.let { map["distribution"] = it }
			}
			data.baseline?.let { value ->
				ExperimentVariant.encode(value)?.let { map["baseline"] = it }
			}
			data.variants?.let { value ->
				ListEncoder.encode(value) { item ->
					ExperimentVariant.encode(item)
				}?.let { map["variants"] = it }
			}
			data.seed?.let { value ->
				IntEncoder.encode(value)?.let { map["seed"] = it }
			}
			data.frequency?.let { value ->
				ExperimentFrequency.encode(value)?.let { map["frequency"] = it }
			}
			data.startedAt?.let { value ->
				DateTimeEncoder.encode(value)?.let { map["startedAt"] = it }
			}
			data.endedAt?.let { value ->
				DateTimeEncoder.encode(value)?.let { map["endedAt"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class ExperimentConfigs (
	val configs: List<ExperimentConfig>? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ExperimentConfigs? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ExperimentConfigs(
				configs = ListDecoder.decode(element.jsonObject["configs"]) { element: JsonElement? ->
				ExperimentConfig.decode(element)
			},
			)
		}

		fun encode(data: ExperimentConfigs?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ExperimentConfigs")
			data.configs?.let { value ->
				ListEncoder.encode(value) { item ->
					ExperimentConfig.encode(item)
				}?.let { map["configs"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class ExperimentFrequency (
	val period: Int? = null,
	val unit: FrequencyUnit? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ExperimentFrequency? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ExperimentFrequency(
				period = IntDecoder.decode(element.jsonObject["period"]),
				unit = FrequencyUnit.decode(element.jsonObject["unit"]),
			)
		}

		fun encode(data: ExperimentFrequency?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ExperimentFrequency")
			data.period?.let { value ->
				IntEncoder.encode(value)?.let { map["period"] = it }
			}
			data.unit?.let { value ->
				FrequencyUnit.encode(value)?.let { map["unit"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class ExperimentKind {
	EMBED,
	POPUP,
	TOOLTIP,
	CONFIG,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): ExperimentKind? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"EMBED" -> EMBED
				"POPUP" -> POPUP
				"TOOLTIP" -> TOOLTIP
				"CONFIG" -> CONFIG
				else -> UNKNOWN
			}
		}

		fun encode(data: ExperimentKind?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				EMBED -> JsonPrimitive("EMBED")
				POPUP -> JsonPrimitive("POPUP")
				TOOLTIP -> JsonPrimitive("TOOLTIP")
				CONFIG -> JsonPrimitive("CONFIG")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class ExperimentVariant (
	val id: ID? = null,
	val configs: List<VariantConfig>? = null,
	val weight: Int? = null,
) {
	companion object {
		fun decode(element: JsonElement?): ExperimentVariant? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return ExperimentVariant(
				id = StringDecoder.decode(element.jsonObject["id"]),
				configs = ListDecoder.decode(element.jsonObject["configs"]) { element: JsonElement? ->
				VariantConfig.decode(element)
			},
				weight = IntDecoder.decode(element.jsonObject["weight"]),
			)
		}

		fun encode(data: ExperimentVariant?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("ExperimentVariant")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.configs?.let { value ->
				ListEncoder.encode(value) { item ->
					VariantConfig.encode(item)
				}?.let { map["configs"] = it }
			}
			data.weight?.let { value ->
				IntEncoder.encode(value)?.let { map["weight"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class FlexDirection {
	ROW,
	COLUMN,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): FlexDirection? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"ROW" -> ROW
				"COLUMN" -> COLUMN
				else -> UNKNOWN
			}
		}

		fun encode(data: FlexDirection?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				ROW -> JsonPrimitive("ROW")
				COLUMN -> JsonPrimitive("COLUMN")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class FontDesign {
	DEFAULT,
	MONOSPACE,
	ROUNDED,
	SERIF,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): FontDesign? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"DEFAULT" -> DEFAULT
				"MONOSPACE" -> MONOSPACE
				"ROUNDED" -> ROUNDED
				"SERIF" -> SERIF
				else -> UNKNOWN
			}
		}

		fun encode(data: FontDesign?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				DEFAULT -> JsonPrimitive("DEFAULT")
				MONOSPACE -> JsonPrimitive("MONOSPACE")
				ROUNDED -> JsonPrimitive("ROUNDED")
				SERIF -> JsonPrimitive("SERIF")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class FontWeight {
	ULTRA_LIGHT,
	THIN,
	LIGHT,
	REGULAR,
	MEDIUM,
	SEMI_BOLD,
	BOLD,
	HEAVY,
	BLACK,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): FontWeight? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"ULTRA_LIGHT" -> ULTRA_LIGHT
				"THIN" -> THIN
				"LIGHT" -> LIGHT
				"REGULAR" -> REGULAR
				"MEDIUM" -> MEDIUM
				"SEMI_BOLD" -> SEMI_BOLD
				"BOLD" -> BOLD
				"HEAVY" -> HEAVY
				"BLACK" -> BLACK
				else -> UNKNOWN
			}
		}

		fun encode(data: FontWeight?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				ULTRA_LIGHT -> JsonPrimitive("ULTRA_LIGHT")
				THIN -> JsonPrimitive("THIN")
				LIGHT -> JsonPrimitive("LIGHT")
				REGULAR -> JsonPrimitive("REGULAR")
				MEDIUM -> JsonPrimitive("MEDIUM")
				SEMI_BOLD -> JsonPrimitive("SEMI_BOLD")
				BOLD -> JsonPrimitive("BOLD")
				HEAVY -> JsonPrimitive("HEAVY")
				BLACK -> JsonPrimitive("BLACK")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class FrameData (
	val width: Int? = null,
	val height: Int? = null,
	val paddingLeft: Int? = null,
	val paddingRight: Int? = null,
	val paddingTop: Int? = null,
	val paddingBottom: Int? = null,
	val borderRadius: Int? = null,
	val borderTopLeftRadius: Int? = null,
	val borderTopRightRadius: Int? = null,
	val borderBottomRightRadius: Int? = null,
	val borderBottomLeftRadius: Int? = null,
	val borderWidth: Int? = null,
	val borderColor: Color? = null,
	val background: Color? = null,
	val backgroundSrc: String? = null,
	val shadow: BoxShadow? = null,
) {
	companion object {
		fun decode(element: JsonElement?): FrameData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return FrameData(
				width = IntDecoder.decode(element.jsonObject["width"]),
				height = IntDecoder.decode(element.jsonObject["height"]),
				paddingLeft = IntDecoder.decode(element.jsonObject["paddingLeft"]),
				paddingRight = IntDecoder.decode(element.jsonObject["paddingRight"]),
				paddingTop = IntDecoder.decode(element.jsonObject["paddingTop"]),
				paddingBottom = IntDecoder.decode(element.jsonObject["paddingBottom"]),
				borderRadius = IntDecoder.decode(element.jsonObject["borderRadius"]),
				borderTopLeftRadius = IntDecoder.decode(element.jsonObject["borderTopLeftRadius"]),
				borderTopRightRadius = IntDecoder.decode(element.jsonObject["borderTopRightRadius"]),
				borderBottomRightRadius = IntDecoder.decode(element.jsonObject["borderBottomRightRadius"]),
				borderBottomLeftRadius = IntDecoder.decode(element.jsonObject["borderBottomLeftRadius"]),
				borderWidth = IntDecoder.decode(element.jsonObject["borderWidth"]),
				borderColor = Color.decode(element.jsonObject["borderColor"]),
				background = Color.decode(element.jsonObject["background"]),
				backgroundSrc = StringDecoder.decode(element.jsonObject["backgroundSrc"]),
				shadow = BoxShadow.decode(element.jsonObject["shadow"]),
			)
		}

		fun encode(data: FrameData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("FrameData")
			data.width?.let { value ->
				IntEncoder.encode(value)?.let { map["width"] = it }
			}
			data.height?.let { value ->
				IntEncoder.encode(value)?.let { map["height"] = it }
			}
			data.paddingLeft?.let { value ->
				IntEncoder.encode(value)?.let { map["paddingLeft"] = it }
			}
			data.paddingRight?.let { value ->
				IntEncoder.encode(value)?.let { map["paddingRight"] = it }
			}
			data.paddingTop?.let { value ->
				IntEncoder.encode(value)?.let { map["paddingTop"] = it }
			}
			data.paddingBottom?.let { value ->
				IntEncoder.encode(value)?.let { map["paddingBottom"] = it }
			}
			data.borderRadius?.let { value ->
				IntEncoder.encode(value)?.let { map["borderRadius"] = it }
			}
			data.borderTopLeftRadius?.let { value ->
				IntEncoder.encode(value)?.let { map["borderTopLeftRadius"] = it }
			}
			data.borderTopRightRadius?.let { value ->
				IntEncoder.encode(value)?.let { map["borderTopRightRadius"] = it }
			}
			data.borderBottomRightRadius?.let { value ->
				IntEncoder.encode(value)?.let { map["borderBottomRightRadius"] = it }
			}
			data.borderBottomLeftRadius?.let { value ->
				IntEncoder.encode(value)?.let { map["borderBottomLeftRadius"] = it }
			}
			data.borderWidth?.let { value ->
				IntEncoder.encode(value)?.let { map["borderWidth"] = it }
			}
			data.borderColor?.let { value ->
				Color.encode(value)?.let { map["borderColor"] = it }
			}
			data.background?.let { value ->
				Color.encode(value)?.let { map["background"] = it }
			}
			data.backgroundSrc?.let { value ->
				StringEncoder.encode(value)?.let { map["backgroundSrc"] = it }
			}
			data.shadow?.let { value ->
				BoxShadow.encode(value)?.let { map["shadow"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class FrequencyUnit {
	DAY,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): FrequencyUnit? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"DAY" -> DAY
				else -> UNKNOWN
			}
		}

		fun encode(data: FrequencyUnit?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				DAY -> JsonPrimitive("DAY")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class ImageContentMode {
	FIT,
	FILL,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): ImageContentMode? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"FIT" -> FIT
				"FILL" -> FILL
				else -> UNKNOWN
			}
		}

		fun encode(data: ImageContentMode?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				FIT -> JsonPrimitive("FIT")
				FILL -> JsonPrimitive("FILL")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class JustifyContent {
	START,
	CENTER,
	END,
	SPACE_BETWEEN,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): JustifyContent? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"START" -> START
				"CENTER" -> CENTER
				"END" -> END
				"SPACE_BETWEEN" -> SPACE_BETWEEN
				else -> UNKNOWN
			}
		}

		fun encode(data: JustifyContent?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				START -> JsonPrimitive("START")
				CENTER -> JsonPrimitive("CENTER")
				END -> JsonPrimitive("END")
				SPACE_BETWEEN -> JsonPrimitive("SPACE_BETWEEN")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class ModalPresentationStyle {
	DEPENDS_ON_CONTEXT_OR_FULL_SCREEN,
	DEPENDS_ON_CONTEXT_OR_PAGE_SHEET,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): ModalPresentationStyle? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"DEPENDS_ON_CONTEXT_OR_FULL_SCREEN" -> DEPENDS_ON_CONTEXT_OR_FULL_SCREEN
				"DEPENDS_ON_CONTEXT_OR_PAGE_SHEET" -> DEPENDS_ON_CONTEXT_OR_PAGE_SHEET
				else -> UNKNOWN
			}
		}

		fun encode(data: ModalPresentationStyle?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				DEPENDS_ON_CONTEXT_OR_FULL_SCREEN -> JsonPrimitive("DEPENDS_ON_CONTEXT_OR_FULL_SCREEN")
				DEPENDS_ON_CONTEXT_OR_PAGE_SHEET -> JsonPrimitive("DEPENDS_ON_CONTEXT_OR_PAGE_SHEET")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class ModalScreenSize {
	MEDIUM,
	LARGE,
	MEDIUM_AND_LARGE,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): ModalScreenSize? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"MEDIUM" -> MEDIUM
				"LARGE" -> LARGE
				"MEDIUM_AND_LARGE" -> MEDIUM_AND_LARGE
				else -> UNKNOWN
			}
		}

		fun encode(data: ModalScreenSize?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				MEDIUM -> JsonPrimitive("MEDIUM")
				LARGE -> JsonPrimitive("LARGE")
				MEDIUM_AND_LARGE -> JsonPrimitive("MEDIUM_AND_LARGE")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class NavigationBackButton (
	val title: String? = null,
	val color: Color? = null,
	val visible: Boolean? = null,
) {
	companion object {
		fun decode(element: JsonElement?): NavigationBackButton? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return NavigationBackButton(
				title = StringDecoder.decode(element.jsonObject["title"]),
				color = Color.decode(element.jsonObject["color"]),
				visible = BooleanDecoder.decode(element.jsonObject["visible"]),
			)
		}

		fun encode(data: NavigationBackButton?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("NavigationBackButton")
			data.title?.let { value ->
				StringEncoder.encode(value)?.let { map["title"] = it }
			}
			data.color?.let { value ->
				Color.encode(value)?.let { map["color"] = it }
			}
			data.visible?.let { value ->
				BooleanEncoder.encode(value)?.let { map["visible"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class Overflow {
	VISIBLE,
	HIDDEN,
	SCROLL,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): Overflow? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"VISIBLE" -> VISIBLE
				"HIDDEN" -> HIDDEN
				"SCROLL" -> SCROLL
				else -> UNKNOWN
			}
		}

		fun encode(data: Overflow?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				VISIBLE -> JsonPrimitive("VISIBLE")
				HIDDEN -> JsonPrimitive("HIDDEN")
				SCROLL -> JsonPrimitive("SCROLL")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class PageKind {
	COMPONENT,
	MODAL,
	WEBVIEW_MODAL,
	TOOLTIP,
	TRIGGER,
	LOAD_BALANCER,
	DISMISSED,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): PageKind? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"COMPONENT" -> COMPONENT
				"MODAL" -> MODAL
				"WEBVIEW_MODAL" -> WEBVIEW_MODAL
				"TOOLTIP" -> TOOLTIP
				"TRIGGER" -> TRIGGER
				"LOAD_BALANCER" -> LOAD_BALANCER
				"DISMISSED" -> DISMISSED
				else -> UNKNOWN
			}
		}

		fun encode(data: PageKind?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				COMPONENT -> JsonPrimitive("COMPONENT")
				MODAL -> JsonPrimitive("MODAL")
				WEBVIEW_MODAL -> JsonPrimitive("WEBVIEW_MODAL")
				TOOLTIP -> JsonPrimitive("TOOLTIP")
				TRIGGER -> JsonPrimitive("TRIGGER")
				LOAD_BALANCER -> JsonPrimitive("LOAD_BALANCER")
				DISMISSED -> JsonPrimitive("DISMISSED")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class Property (
	val name: String? = null,
	val value: String? = null,
	val ptype: PropertyType? = null,
) {
	companion object {
		fun decode(element: JsonElement?): Property? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return Property(
				name = StringDecoder.decode(element.jsonObject["name"]),
				value = StringDecoder.decode(element.jsonObject["value"]),
				ptype = PropertyType.decode(element.jsonObject["ptype"]),
			)
		}

		fun encode(data: Property?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("Property")
			data.name?.let { value ->
				StringEncoder.encode(value)?.let { map["name"] = it }
			}
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}
			data.ptype?.let { value ->
				PropertyType.encode(value)?.let { map["ptype"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class PropertyType {
	INTEGER,
	STRING,
	TIMESTAMPZ,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): PropertyType? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"INTEGER" -> INTEGER
				"STRING" -> STRING
				"TIMESTAMPZ" -> TIMESTAMPZ
				else -> UNKNOWN
			}
		}

		fun encode(data: PropertyType?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				INTEGER -> JsonPrimitive("INTEGER")
				STRING -> JsonPrimitive("STRING")
				TIMESTAMPZ -> JsonPrimitive("TIMESTAMPZ")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class TextAlign {
	NATURAL,
	LEFT,
	CENTER,
	RIGHT,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): TextAlign? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"NATURAL" -> NATURAL
				"LEFT" -> LEFT
				"CENTER" -> CENTER
				"RIGHT" -> RIGHT
				else -> UNKNOWN
			}
		}

		fun encode(data: TextAlign?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				NATURAL -> JsonPrimitive("NATURAL")
				LEFT -> JsonPrimitive("LEFT")
				CENTER -> JsonPrimitive("CENTER")
				RIGHT -> JsonPrimitive("RIGHT")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class TriggerEventDef (
	val name: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): TriggerEventDef? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return TriggerEventDef(
				name = StringDecoder.decode(element.jsonObject["name"]),
			)
		}

		fun encode(data: TriggerEventDef?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("TriggerEventDef")
			data.name?.let { value ->
				StringEncoder.encode(value)?.let { map["name"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class TriggerEventNameDefs {
	RETENTION_1,
	RETENTION_2_3,
	RETENTION_4_7,
	RETENTION_8_14,
	RETENTION_15,
	USER_BOOT_APP,
	USER_ENTER_TO_APP,
	USER_ENTER_TO_APP_FIRSTLY,
	USER_ENTER_TO_FOREGROUND,
	N_ERROR_RECORD,
	N_ERROR_IN_SDK_RECORD,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): TriggerEventNameDefs? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"RETENTION_1" -> RETENTION_1
				"RETENTION_2_3" -> RETENTION_2_3
				"RETENTION_4_7" -> RETENTION_4_7
				"RETENTION_8_14" -> RETENTION_8_14
				"RETENTION_15" -> RETENTION_15
				"USER_BOOT_APP" -> USER_BOOT_APP
				"USER_ENTER_TO_APP" -> USER_ENTER_TO_APP
				"USER_ENTER_TO_APP_FIRSTLY" -> USER_ENTER_TO_APP_FIRSTLY
				"USER_ENTER_TO_FOREGROUND" -> USER_ENTER_TO_FOREGROUND
				"N_ERROR_RECORD" -> N_ERROR_RECORD
				"N_ERROR_IN_SDK_RECORD" -> N_ERROR_IN_SDK_RECORD
				else -> UNKNOWN
			}
		}

		fun encode(data: TriggerEventNameDefs?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				RETENTION_1 -> JsonPrimitive("RETENTION_1")
				RETENTION_2_3 -> JsonPrimitive("RETENTION_2_3")
				RETENTION_4_7 -> JsonPrimitive("RETENTION_4_7")
				RETENTION_8_14 -> JsonPrimitive("RETENTION_8_14")
				RETENTION_15 -> JsonPrimitive("RETENTION_15")
				USER_BOOT_APP -> JsonPrimitive("USER_BOOT_APP")
				USER_ENTER_TO_APP -> JsonPrimitive("USER_ENTER_TO_APP")
				USER_ENTER_TO_APP_FIRSTLY -> JsonPrimitive("USER_ENTER_TO_APP_FIRSTLY")
				USER_ENTER_TO_FOREGROUND -> JsonPrimitive("USER_ENTER_TO_FOREGROUND")
				N_ERROR_RECORD -> JsonPrimitive("N_ERROR_RECORD")
				N_ERROR_IN_SDK_RECORD -> JsonPrimitive("N_ERROR_IN_SDK_RECORD")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class TriggerSetting (
	val onTrigger: UIBlockEventDispatcher? = null,
	val trigger: TriggerEventDef? = null,
) {
	companion object {
		fun decode(element: JsonElement?): TriggerSetting? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return TriggerSetting(
				onTrigger = UIBlockEventDispatcher.decode(element.jsonObject["onTrigger"]),
				trigger = TriggerEventDef.decode(element.jsonObject["trigger"]),
			)
		}

		fun encode(data: TriggerSetting?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("TriggerSetting")
			data.onTrigger?.let { value ->
				UIBlockEventDispatcher.encode(value)?.let { map["onTrigger"] = it }
			}
			data.trigger?.let { value ->
				TriggerEventDef.encode(value)?.let { map["trigger"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal sealed class UIBlock {
	class UnionUIRootBlock(var data: UIRootBlock): UIBlock()
	class UnionUIPageBlock(var data: UIPageBlock): UIBlock()
	class UnionUIFlexContainerBlock(var data: UIFlexContainerBlock): UIBlock()
	class UnionUITextBlock(var data: UITextBlock): UIBlock()
	class UnionUIImageBlock(var data: UIImageBlock): UIBlock()
	class UnionUICollectionBlock(var data: UICollectionBlock): UIBlock()
	class UnionUICarouselBlock(var data: UICarouselBlock): UIBlock()
	class UnionUITextInputBlock(var data: UITextInputBlock): UIBlock()
	class UnionUISelectInputBlock(var data: UISelectInputBlock): UIBlock()
	class UnionUIMultiSelectInputBlock(var data: UIMultiSelectInputBlock): UIBlock()
	class UnionUISwitchInputBlock(var data: UISwitchInputBlock): UIBlock()

	companion object {
		fun decode(element: JsonElement?): UIBlock? {
			if (element == null) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}
			val typename = element.jsonObject["__typename"] ?: return null
			if (typename !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}

			return when (typename.jsonPrimitive.content) {
				"UIRootBlock" -> UIRootBlock.decode(element)?.let { UnionUIRootBlock(it) }
				"UIPageBlock" -> UIPageBlock.decode(element)?.let { UnionUIPageBlock(it) }
				"UIFlexContainerBlock" -> UIFlexContainerBlock.decode(element)?.let { UnionUIFlexContainerBlock(it) }
				"UITextBlock" -> UITextBlock.decode(element)?.let { UnionUITextBlock(it) }
				"UIImageBlock" -> UIImageBlock.decode(element)?.let { UnionUIImageBlock(it) }
				"UICollectionBlock" -> UICollectionBlock.decode(element)?.let { UnionUICollectionBlock(it) }
				"UICarouselBlock" -> UICarouselBlock.decode(element)?.let { UnionUICarouselBlock(it) }
				"UITextInputBlock" -> UITextInputBlock.decode(element)?.let { UnionUITextInputBlock(it) }
				"UISelectInputBlock" -> UISelectInputBlock.decode(element)?.let { UnionUISelectInputBlock(it) }
				"UIMultiSelectInputBlock" -> UIMultiSelectInputBlock.decode(element)?.let { UnionUIMultiSelectInputBlock(it) }
				"UISwitchInputBlock" -> UISwitchInputBlock.decode(element)?.let { UnionUISwitchInputBlock(it) }
				else -> null
			}
		}

		fun encode(data: UIBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()

			when (data) {
				is UnionUIRootBlock -> {
					UIRootBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUIPageBlock -> {
					UIPageBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUIFlexContainerBlock -> {
					UIFlexContainerBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUITextBlock -> {
					UITextBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUIImageBlock -> {
					UIImageBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUICollectionBlock -> {
					UICollectionBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUICarouselBlock -> {
					UICarouselBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUITextInputBlock -> {
					UITextInputBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUISelectInputBlock -> {
					UISelectInputBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUIMultiSelectInputBlock -> {
					UIMultiSelectInputBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				is UnionUISwitchInputBlock -> {
					UISwitchInputBlock.encode(data.data)?.let {
						if (it is JsonObject) {
							map.putAll(it.jsonObject)
						}
					}
				}
				else -> return JsonNull
			}

			return JsonObject(map)
		}
	}
}


internal class UIBlockEventDispatcher (
	val name: String? = null,
	val destinationPageId: String? = null,
	val deepLink: String? = null,
	val payload: List<Property>? = null,
	val requiredFields: List<String>? = null,
	val httpRequest: ApiHttpRequest? = null,
	val httpResponseAssertion: ApiHttpResponseAssertion? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIBlockEventDispatcher? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIBlockEventDispatcher(
				name = StringDecoder.decode(element.jsonObject["name"]),
				destinationPageId = StringDecoder.decode(element.jsonObject["destinationPageId"]),
				deepLink = StringDecoder.decode(element.jsonObject["deepLink"]),
				payload = ListDecoder.decode(element.jsonObject["payload"]) { element: JsonElement? ->
				Property.decode(element)
			},
				requiredFields = ListDecoder.decode(element.jsonObject["requiredFields"]) { element: JsonElement? ->
				StringDecoder.decode(element)
			},
				httpRequest = ApiHttpRequest.decode(element.jsonObject["httpRequest"]),
				httpResponseAssertion = ApiHttpResponseAssertion.decode(element.jsonObject["httpResponseAssertion"]),
			)
		}

		fun encode(data: UIBlockEventDispatcher?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIBlockEventDispatcher")
			data.name?.let { value ->
				StringEncoder.encode(value)?.let { map["name"] = it }
			}
			data.destinationPageId?.let { value ->
				StringEncoder.encode(value)?.let { map["destinationPageId"] = it }
			}
			data.deepLink?.let { value ->
				StringEncoder.encode(value)?.let { map["deepLink"] = it }
			}
			data.payload?.let { value ->
				ListEncoder.encode(value) { item ->
					Property.encode(item)
				}?.let { map["payload"] = it }
			}
			data.requiredFields?.let { value ->
				ListEncoder.encode(value) { item ->
					StringEncoder.encode(item)
				}?.let { map["requiredFields"] = it }
			}
			data.httpRequest?.let { value ->
				ApiHttpRequest.encode(value)?.let { map["httpRequest"] = it }
			}
			data.httpResponseAssertion?.let { value ->
				ApiHttpResponseAssertion.encode(value)?.let { map["httpResponseAssertion"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UICarouselBlock (
	val id: ID? = null,
	val data: UICarouselBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UICarouselBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UICarouselBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UICarouselBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UICarouselBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UICarouselBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UICarouselBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UICarouselBlockData (
	val children: List<UIBlock>? = null,
	val frame: FrameData? = null,
	val gap: Int? = null,
	val onClick: UIBlockEventDispatcher? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UICarouselBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UICarouselBlockData(
				children = ListDecoder.decode(element.jsonObject["children"]) { element: JsonElement? ->
				UIBlock.decode(element)
			},
				frame = FrameData.decode(element.jsonObject["frame"]),
				gap = IntDecoder.decode(element.jsonObject["gap"]),
				onClick = UIBlockEventDispatcher.decode(element.jsonObject["onClick"]),
			)
		}

		fun encode(data: UICarouselBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UICarouselBlockData")
			data.children?.let { value ->
				ListEncoder.encode(value) { item ->
					UIBlock.encode(item)
				}?.let { map["children"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}
			data.gap?.let { value ->
				IntEncoder.encode(value)?.let { map["gap"] = it }
			}
			data.onClick?.let { value ->
				UIBlockEventDispatcher.encode(value)?.let { map["onClick"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UICollectionBlock (
	val id: ID? = null,
	val data: UICollectionBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UICollectionBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UICollectionBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UICollectionBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UICollectionBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UICollectionBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UICollectionBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UICollectionBlockData (
	val children: List<UIBlock>? = null,
	val frame: FrameData? = null,
	val gap: Int? = null,
	val kind: CollectionKind? = null,
	val direction: FlexDirection? = null,
	val reference: String? = null,
	val gridSize: Int? = null,
	val itemWidth: Int? = null,
	val itemHeight: Int? = null,
	val fullItemWidth: Boolean? = null,
	val pageControl: Boolean? = null,
	val autoScroll: Boolean? = null,
	val autoScrollInterval: Float? = null,
	val onClick: UIBlockEventDispatcher? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UICollectionBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UICollectionBlockData(
				children = ListDecoder.decode(element.jsonObject["children"]) { element: JsonElement? ->
				UIBlock.decode(element)
			},
				frame = FrameData.decode(element.jsonObject["frame"]),
				gap = IntDecoder.decode(element.jsonObject["gap"]),
				kind = CollectionKind.decode(element.jsonObject["kind"]),
				direction = FlexDirection.decode(element.jsonObject["direction"]),
				reference = StringDecoder.decode(element.jsonObject["reference"]),
				gridSize = IntDecoder.decode(element.jsonObject["gridSize"]),
				itemWidth = IntDecoder.decode(element.jsonObject["itemWidth"]),
				itemHeight = IntDecoder.decode(element.jsonObject["itemHeight"]),
				fullItemWidth = BooleanDecoder.decode(element.jsonObject["fullItemWidth"]),
				pageControl = BooleanDecoder.decode(element.jsonObject["pageControl"]),
				autoScroll = BooleanDecoder.decode(element.jsonObject["autoScroll"]),
				autoScrollInterval = FloatDecoder.decode(element.jsonObject["autoScrollInterval"]),
				onClick = UIBlockEventDispatcher.decode(element.jsonObject["onClick"]),
			)
		}

		fun encode(data: UICollectionBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UICollectionBlockData")
			data.children?.let { value ->
				ListEncoder.encode(value) { item ->
					UIBlock.encode(item)
				}?.let { map["children"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}
			data.gap?.let { value ->
				IntEncoder.encode(value)?.let { map["gap"] = it }
			}
			data.kind?.let { value ->
				CollectionKind.encode(value)?.let { map["kind"] = it }
			}
			data.direction?.let { value ->
				FlexDirection.encode(value)?.let { map["direction"] = it }
			}
			data.reference?.let { value ->
				StringEncoder.encode(value)?.let { map["reference"] = it }
			}
			data.gridSize?.let { value ->
				IntEncoder.encode(value)?.let { map["gridSize"] = it }
			}
			data.itemWidth?.let { value ->
				IntEncoder.encode(value)?.let { map["itemWidth"] = it }
			}
			data.itemHeight?.let { value ->
				IntEncoder.encode(value)?.let { map["itemHeight"] = it }
			}
			data.fullItemWidth?.let { value ->
				BooleanEncoder.encode(value)?.let { map["fullItemWidth"] = it }
			}
			data.pageControl?.let { value ->
				BooleanEncoder.encode(value)?.let { map["pageControl"] = it }
			}
			data.autoScroll?.let { value ->
				BooleanEncoder.encode(value)?.let { map["autoScroll"] = it }
			}
			data.autoScrollInterval?.let { value ->
				FloatEncoder.encode(value)?.let { map["autoScrollInterval"] = it }
			}
			data.onClick?.let { value ->
				UIBlockEventDispatcher.encode(value)?.let { map["onClick"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIFlexContainerBlock (
	val id: ID? = null,
	val data: UIFlexContainerBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIFlexContainerBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIFlexContainerBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UIFlexContainerBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UIFlexContainerBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIFlexContainerBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UIFlexContainerBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIFlexContainerBlockData (
	val children: List<UIBlock>? = null,
	val direction: FlexDirection? = null,
	val justifyContent: JustifyContent? = null,
	val alignItems: AlignItems? = null,
	val gap: Int? = null,
	val frame: FrameData? = null,
	val overflow: Overflow? = null,
	val onClick: UIBlockEventDispatcher? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIFlexContainerBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIFlexContainerBlockData(
				children = ListDecoder.decode(element.jsonObject["children"]) { element: JsonElement? ->
				UIBlock.decode(element)
			},
				direction = FlexDirection.decode(element.jsonObject["direction"]),
				justifyContent = JustifyContent.decode(element.jsonObject["justifyContent"]),
				alignItems = AlignItems.decode(element.jsonObject["alignItems"]),
				gap = IntDecoder.decode(element.jsonObject["gap"]),
				frame = FrameData.decode(element.jsonObject["frame"]),
				overflow = Overflow.decode(element.jsonObject["overflow"]),
				onClick = UIBlockEventDispatcher.decode(element.jsonObject["onClick"]),
			)
		}

		fun encode(data: UIFlexContainerBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIFlexContainerBlockData")
			data.children?.let { value ->
				ListEncoder.encode(value) { item ->
					UIBlock.encode(item)
				}?.let { map["children"] = it }
			}
			data.direction?.let { value ->
				FlexDirection.encode(value)?.let { map["direction"] = it }
			}
			data.justifyContent?.let { value ->
				JustifyContent.encode(value)?.let { map["justifyContent"] = it }
			}
			data.alignItems?.let { value ->
				AlignItems.encode(value)?.let { map["alignItems"] = it }
			}
			data.gap?.let { value ->
				IntEncoder.encode(value)?.let { map["gap"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}
			data.overflow?.let { value ->
				Overflow.encode(value)?.let { map["overflow"] = it }
			}
			data.onClick?.let { value ->
				UIBlockEventDispatcher.encode(value)?.let { map["onClick"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIImageBlock (
	val id: ID? = null,
	val data: UIImageBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIImageBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIImageBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UIImageBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UIImageBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIImageBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UIImageBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIImageBlockData (
	val src: String? = null,
	val contentMode: ImageContentMode? = null,
	val frame: FrameData? = null,
	val onClick: UIBlockEventDispatcher? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIImageBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIImageBlockData(
				src = StringDecoder.decode(element.jsonObject["src"]),
				contentMode = ImageContentMode.decode(element.jsonObject["contentMode"]),
				frame = FrameData.decode(element.jsonObject["frame"]),
				onClick = UIBlockEventDispatcher.decode(element.jsonObject["onClick"]),
			)
		}

		fun encode(data: UIImageBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIImageBlockData")
			data.src?.let { value ->
				StringEncoder.encode(value)?.let { map["src"] = it }
			}
			data.contentMode?.let { value ->
				ImageContentMode.encode(value)?.let { map["contentMode"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}
			data.onClick?.let { value ->
				UIBlockEventDispatcher.encode(value)?.let { map["onClick"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIMultiSelectInputBlock (
	val id: ID? = null,
	val data: UIMultiSelectInputBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIMultiSelectInputBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIMultiSelectInputBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UIMultiSelectInputBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UIMultiSelectInputBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIMultiSelectInputBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UIMultiSelectInputBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIMultiSelectInputBlockData (
	val key: String? = null,
	val options: List<UISelectInputOption>? = null,
	val value: List<String>? = null,
	val placeholder: String? = null,
	val size: Int? = null,
	val color: Color? = null,
	val design: FontDesign? = null,
	val weight: FontWeight? = null,
	val textAlign: TextAlign? = null,
	val frame: FrameData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIMultiSelectInputBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIMultiSelectInputBlockData(
				key = StringDecoder.decode(element.jsonObject["key"]),
				options = ListDecoder.decode(element.jsonObject["options"]) { element: JsonElement? ->
				UISelectInputOption.decode(element)
			},
				value = ListDecoder.decode(element.jsonObject["value"]) { element: JsonElement? ->
				StringDecoder.decode(element)
			},
				placeholder = StringDecoder.decode(element.jsonObject["placeholder"]),
				size = IntDecoder.decode(element.jsonObject["size"]),
				color = Color.decode(element.jsonObject["color"]),
				design = FontDesign.decode(element.jsonObject["design"]),
				weight = FontWeight.decode(element.jsonObject["weight"]),
				textAlign = TextAlign.decode(element.jsonObject["textAlign"]),
				frame = FrameData.decode(element.jsonObject["frame"]),
			)
		}

		fun encode(data: UIMultiSelectInputBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIMultiSelectInputBlockData")
			data.key?.let { value ->
				StringEncoder.encode(value)?.let { map["key"] = it }
			}
			data.options?.let { value ->
				ListEncoder.encode(value) { item ->
					UISelectInputOption.encode(item)
				}?.let { map["options"] = it }
			}
			data.value?.let { value ->
				ListEncoder.encode(value) { item ->
					StringEncoder.encode(item)
				}?.let { map["value"] = it }
			}
			data.placeholder?.let { value ->
				StringEncoder.encode(value)?.let { map["placeholder"] = it }
			}
			data.size?.let { value ->
				IntEncoder.encode(value)?.let { map["size"] = it }
			}
			data.color?.let { value ->
				Color.encode(value)?.let { map["color"] = it }
			}
			data.design?.let { value ->
				FontDesign.encode(value)?.let { map["design"] = it }
			}
			data.weight?.let { value ->
				FontWeight.encode(value)?.let { map["weight"] = it }
			}
			data.textAlign?.let { value ->
				TextAlign.encode(value)?.let { map["textAlign"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIPageBlock (
	val id: ID? = null,
	val name: String? = null,
	val data: UIPageBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIPageBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIPageBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				name = StringDecoder.decode(element.jsonObject["name"]),
				data = UIPageBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UIPageBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIPageBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.name?.let { value ->
				StringEncoder.encode(value)?.let { map["name"] = it }
			}
			data.data?.let { value ->
				UIPageBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIPageBlockData (
	val kind: PageKind? = null,
	val modalPresentationStyle: ModalPresentationStyle? = null,
	val modalScreenSize: ModalScreenSize? = null,
	val modalNavigationBackButton: NavigationBackButton? = null,
	val modalRespectSafeArea: Boolean? = null,
	val webviewUrl: String? = null,
	val triggerSetting: TriggerSetting? = null,
	val renderAs: UIBlock? = null,
	val position: UIPageBlockPosition? = null,
	val httpRequest: ApiHttpRequest? = null,
	val tooltipSize: UITooltipSize? = null,
	val tooltipAnchor: String? = null,
	val tooltipPlacement: UITooltipPlacement? = null,
	val tooltipTransitionTarget: UITooltipTransitionTarget? = null,
	val props: List<Property>? = null,
	val query: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIPageBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIPageBlockData(
				kind = PageKind.decode(element.jsonObject["kind"]),
				modalPresentationStyle = ModalPresentationStyle.decode(element.jsonObject["modalPresentationStyle"]),
				modalScreenSize = ModalScreenSize.decode(element.jsonObject["modalScreenSize"]),
				modalNavigationBackButton = NavigationBackButton.decode(element.jsonObject["modalNavigationBackButton"]),
				modalRespectSafeArea = BooleanDecoder.decode(element.jsonObject["modalRespectSafeArea"]),
				webviewUrl = StringDecoder.decode(element.jsonObject["webviewUrl"]),
				triggerSetting = TriggerSetting.decode(element.jsonObject["triggerSetting"]),
				renderAs = UIBlock.decode(element.jsonObject["renderAs"]),
				position = UIPageBlockPosition.decode(element.jsonObject["position"]),
				httpRequest = ApiHttpRequest.decode(element.jsonObject["httpRequest"]),
				tooltipSize = UITooltipSize.decode(element.jsonObject["tooltipSize"]),
				tooltipAnchor = StringDecoder.decode(element.jsonObject["tooltipAnchor"]),
				tooltipPlacement = UITooltipPlacement.decode(element.jsonObject["tooltipPlacement"]),
				tooltipTransitionTarget = UITooltipTransitionTarget.decode(element.jsonObject["tooltipTransitionTarget"]),
				props = ListDecoder.decode(element.jsonObject["props"]) { element: JsonElement? ->
				Property.decode(element)
			},
				query = StringDecoder.decode(element.jsonObject["query"]),
			)
		}

		fun encode(data: UIPageBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIPageBlockData")
			data.kind?.let { value ->
				PageKind.encode(value)?.let { map["kind"] = it }
			}
			data.modalPresentationStyle?.let { value ->
				ModalPresentationStyle.encode(value)?.let { map["modalPresentationStyle"] = it }
			}
			data.modalScreenSize?.let { value ->
				ModalScreenSize.encode(value)?.let { map["modalScreenSize"] = it }
			}
			data.modalNavigationBackButton?.let { value ->
				NavigationBackButton.encode(value)?.let { map["modalNavigationBackButton"] = it }
			}
			data.modalRespectSafeArea?.let { value ->
				BooleanEncoder.encode(value)?.let { map["modalRespectSafeArea"] = it }
			}
			data.webviewUrl?.let { value ->
				StringEncoder.encode(value)?.let { map["webviewUrl"] = it }
			}
			data.triggerSetting?.let { value ->
				TriggerSetting.encode(value)?.let { map["triggerSetting"] = it }
			}
			data.renderAs?.let { value ->
				UIBlock.encode(value)?.let { map["renderAs"] = it }
			}
			data.position?.let { value ->
				UIPageBlockPosition.encode(value)?.let { map["position"] = it }
			}
			data.httpRequest?.let { value ->
				ApiHttpRequest.encode(value)?.let { map["httpRequest"] = it }
			}
			data.tooltipSize?.let { value ->
				UITooltipSize.encode(value)?.let { map["tooltipSize"] = it }
			}
			data.tooltipAnchor?.let { value ->
				StringEncoder.encode(value)?.let { map["tooltipAnchor"] = it }
			}
			data.tooltipPlacement?.let { value ->
				UITooltipPlacement.encode(value)?.let { map["tooltipPlacement"] = it }
			}
			data.tooltipTransitionTarget?.let { value ->
				UITooltipTransitionTarget.encode(value)?.let { map["tooltipTransitionTarget"] = it }
			}
			data.props?.let { value ->
				ListEncoder.encode(value) { item ->
					Property.encode(item)
				}?.let { map["props"] = it }
			}
			data.query?.let { value ->
				StringEncoder.encode(value)?.let { map["query"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIPageBlockPosition (
	val x: Int? = null,
	val y: Int? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIPageBlockPosition? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIPageBlockPosition(
				x = IntDecoder.decode(element.jsonObject["x"]),
				y = IntDecoder.decode(element.jsonObject["y"]),
			)
		}

		fun encode(data: UIPageBlockPosition?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIPageBlockPosition")
			data.x?.let { value ->
				IntEncoder.encode(value)?.let { map["x"] = it }
			}
			data.y?.let { value ->
				IntEncoder.encode(value)?.let { map["y"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIRootBlock (
	val id: ID? = null,
	val data: UIRootBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIRootBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIRootBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UIRootBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UIRootBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIRootBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UIRootBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UIRootBlockData (
	val pages: List<UIPageBlock>? = null,
	val currentPageId: ID? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UIRootBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UIRootBlockData(
				pages = ListDecoder.decode(element.jsonObject["pages"]) { element: JsonElement? ->
				UIPageBlock.decode(element)
			},
				currentPageId = StringDecoder.decode(element.jsonObject["currentPageId"]),
			)
		}

		fun encode(data: UIRootBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UIRootBlockData")
			data.pages?.let { value ->
				ListEncoder.encode(value) { item ->
					UIPageBlock.encode(item)
				}?.let { map["pages"] = it }
			}
			data.currentPageId?.let { value ->
				StringEncoder.encode(value)?.let { map["currentPageId"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UISelectInputBlock (
	val id: ID? = null,
	val data: UISelectInputBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UISelectInputBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UISelectInputBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UISelectInputBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UISelectInputBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UISelectInputBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UISelectInputBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UISelectInputBlockData (
	val key: String? = null,
	val options: List<UISelectInputOption>? = null,
	val value: String? = null,
	val placeholder: String? = null,
	val size: Int? = null,
	val color: Color? = null,
	val design: FontDesign? = null,
	val weight: FontWeight? = null,
	val textAlign: TextAlign? = null,
	val frame: FrameData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UISelectInputBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UISelectInputBlockData(
				key = StringDecoder.decode(element.jsonObject["key"]),
				options = ListDecoder.decode(element.jsonObject["options"]) { element: JsonElement? ->
				UISelectInputOption.decode(element)
			},
				value = StringDecoder.decode(element.jsonObject["value"]),
				placeholder = StringDecoder.decode(element.jsonObject["placeholder"]),
				size = IntDecoder.decode(element.jsonObject["size"]),
				color = Color.decode(element.jsonObject["color"]),
				design = FontDesign.decode(element.jsonObject["design"]),
				weight = FontWeight.decode(element.jsonObject["weight"]),
				textAlign = TextAlign.decode(element.jsonObject["textAlign"]),
				frame = FrameData.decode(element.jsonObject["frame"]),
			)
		}

		fun encode(data: UISelectInputBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UISelectInputBlockData")
			data.key?.let { value ->
				StringEncoder.encode(value)?.let { map["key"] = it }
			}
			data.options?.let { value ->
				ListEncoder.encode(value) { item ->
					UISelectInputOption.encode(item)
				}?.let { map["options"] = it }
			}
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}
			data.placeholder?.let { value ->
				StringEncoder.encode(value)?.let { map["placeholder"] = it }
			}
			data.size?.let { value ->
				IntEncoder.encode(value)?.let { map["size"] = it }
			}
			data.color?.let { value ->
				Color.encode(value)?.let { map["color"] = it }
			}
			data.design?.let { value ->
				FontDesign.encode(value)?.let { map["design"] = it }
			}
			data.weight?.let { value ->
				FontWeight.encode(value)?.let { map["weight"] = it }
			}
			data.textAlign?.let { value ->
				TextAlign.encode(value)?.let { map["textAlign"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UISelectInputOption (
	val value: String? = null,
	val label: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UISelectInputOption? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UISelectInputOption(
				value = StringDecoder.decode(element.jsonObject["value"]),
				label = StringDecoder.decode(element.jsonObject["label"]),
			)
		}

		fun encode(data: UISelectInputOption?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UISelectInputOption")
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}
			data.label?.let { value ->
				StringEncoder.encode(value)?.let { map["label"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UISwitchInputBlock (
	val id: ID? = null,
	val data: UISwitchInputBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UISwitchInputBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UISwitchInputBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UISwitchInputBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UISwitchInputBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UISwitchInputBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UISwitchInputBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UISwitchInputBlockData (
	val key: String? = null,
	val value: Boolean? = null,
	val checkedColor: Color? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UISwitchInputBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UISwitchInputBlockData(
				key = StringDecoder.decode(element.jsonObject["key"]),
				value = BooleanDecoder.decode(element.jsonObject["value"]),
				checkedColor = Color.decode(element.jsonObject["checkedColor"]),
			)
		}

		fun encode(data: UISwitchInputBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UISwitchInputBlockData")
			data.key?.let { value ->
				StringEncoder.encode(value)?.let { map["key"] = it }
			}
			data.value?.let { value ->
				BooleanEncoder.encode(value)?.let { map["value"] = it }
			}
			data.checkedColor?.let { value ->
				Color.encode(value)?.let { map["checkedColor"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UITextBlock (
	val id: ID? = null,
	val data: UITextBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UITextBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UITextBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UITextBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UITextBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UITextBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UITextBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UITextBlockData (
	val value: String? = null,
	val size: Int? = null,
	val color: Color? = null,
	val design: FontDesign? = null,
	val weight: FontWeight? = null,
	val maxLines: Int? = null,
	val frame: FrameData? = null,
	val onClick: UIBlockEventDispatcher? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UITextBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UITextBlockData(
				value = StringDecoder.decode(element.jsonObject["value"]),
				size = IntDecoder.decode(element.jsonObject["size"]),
				color = Color.decode(element.jsonObject["color"]),
				design = FontDesign.decode(element.jsonObject["design"]),
				weight = FontWeight.decode(element.jsonObject["weight"]),
				maxLines = IntDecoder.decode(element.jsonObject["maxLines"]),
				frame = FrameData.decode(element.jsonObject["frame"]),
				onClick = UIBlockEventDispatcher.decode(element.jsonObject["onClick"]),
			)
		}

		fun encode(data: UITextBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UITextBlockData")
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}
			data.size?.let { value ->
				IntEncoder.encode(value)?.let { map["size"] = it }
			}
			data.color?.let { value ->
				Color.encode(value)?.let { map["color"] = it }
			}
			data.design?.let { value ->
				FontDesign.encode(value)?.let { map["design"] = it }
			}
			data.weight?.let { value ->
				FontWeight.encode(value)?.let { map["weight"] = it }
			}
			data.maxLines?.let { value ->
				IntEncoder.encode(value)?.let { map["maxLines"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}
			data.onClick?.let { value ->
				UIBlockEventDispatcher.encode(value)?.let { map["onClick"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UITextInputBlock (
	val id: ID? = null,
	val data: UITextInputBlockData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UITextInputBlock? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UITextInputBlock(
				id = StringDecoder.decode(element.jsonObject["id"]),
				data = UITextInputBlockData.decode(element.jsonObject["data"]),
			)
		}

		fun encode(data: UITextInputBlock?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UITextInputBlock")
			data.id?.let { value ->
				StringEncoder.encode(value)?.let { map["id"] = it }
			}
			data.data?.let { value ->
				UITextInputBlockData.encode(value)?.let { map["data"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal class UITextInputBlockData (
	val key: String? = null,
	val value: String? = null,
	val placeholder: String? = null,
	val regex: String? = null,
	val errorMessage: UITooltipMessage? = null,
	val keyboardType: UITextInputKeyboardType? = null,
	val secure: Boolean? = null,
	val autocorrect: Boolean? = null,
	val size: Int? = null,
	val color: Color? = null,
	val design: FontDesign? = null,
	val weight: FontWeight? = null,
	val textAlign: TextAlign? = null,
	val frame: FrameData? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UITextInputBlockData? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UITextInputBlockData(
				key = StringDecoder.decode(element.jsonObject["key"]),
				value = StringDecoder.decode(element.jsonObject["value"]),
				placeholder = StringDecoder.decode(element.jsonObject["placeholder"]),
				regex = StringDecoder.decode(element.jsonObject["regex"]),
				errorMessage = UITooltipMessage.decode(element.jsonObject["errorMessage"]),
				keyboardType = UITextInputKeyboardType.decode(element.jsonObject["keyboardType"]),
				secure = BooleanDecoder.decode(element.jsonObject["secure"]),
				autocorrect = BooleanDecoder.decode(element.jsonObject["autocorrect"]),
				size = IntDecoder.decode(element.jsonObject["size"]),
				color = Color.decode(element.jsonObject["color"]),
				design = FontDesign.decode(element.jsonObject["design"]),
				weight = FontWeight.decode(element.jsonObject["weight"]),
				textAlign = TextAlign.decode(element.jsonObject["textAlign"]),
				frame = FrameData.decode(element.jsonObject["frame"]),
			)
		}

		fun encode(data: UITextInputBlockData?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UITextInputBlockData")
			data.key?.let { value ->
				StringEncoder.encode(value)?.let { map["key"] = it }
			}
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}
			data.placeholder?.let { value ->
				StringEncoder.encode(value)?.let { map["placeholder"] = it }
			}
			data.regex?.let { value ->
				StringEncoder.encode(value)?.let { map["regex"] = it }
			}
			data.errorMessage?.let { value ->
				UITooltipMessage.encode(value)?.let { map["errorMessage"] = it }
			}
			data.keyboardType?.let { value ->
				UITextInputKeyboardType.encode(value)?.let { map["keyboardType"] = it }
			}
			data.secure?.let { value ->
				BooleanEncoder.encode(value)?.let { map["secure"] = it }
			}
			data.autocorrect?.let { value ->
				BooleanEncoder.encode(value)?.let { map["autocorrect"] = it }
			}
			data.size?.let { value ->
				IntEncoder.encode(value)?.let { map["size"] = it }
			}
			data.color?.let { value ->
				Color.encode(value)?.let { map["color"] = it }
			}
			data.design?.let { value ->
				FontDesign.encode(value)?.let { map["design"] = it }
			}
			data.weight?.let { value ->
				FontWeight.encode(value)?.let { map["weight"] = it }
			}
			data.textAlign?.let { value ->
				TextAlign.encode(value)?.let { map["textAlign"] = it }
			}
			data.frame?.let { value ->
				FrameData.encode(value)?.let { map["frame"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class UITextInputKeyboardType {
	DEFAULT,
	ASCII,
	EMAIL,
	DECIMAL,
	NUMBER,
	URI,
	ALPHABET,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): UITextInputKeyboardType? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"DEFAULT" -> DEFAULT
				"ASCII" -> ASCII
				"EMAIL" -> EMAIL
				"DECIMAL" -> DECIMAL
				"NUMBER" -> NUMBER
				"URI" -> URI
				"ALPHABET" -> ALPHABET
				else -> UNKNOWN
			}
		}

		fun encode(data: UITextInputKeyboardType?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				DEFAULT -> JsonPrimitive("DEFAULT")
				ASCII -> JsonPrimitive("ASCII")
				EMAIL -> JsonPrimitive("EMAIL")
				DECIMAL -> JsonPrimitive("DECIMAL")
				NUMBER -> JsonPrimitive("NUMBER")
				URI -> JsonPrimitive("URI")
				ALPHABET -> JsonPrimitive("ALPHABET")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class UITooltipMessage (
	val title: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UITooltipMessage? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UITooltipMessage(
				title = StringDecoder.decode(element.jsonObject["title"]),
			)
		}

		fun encode(data: UITooltipMessage?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UITooltipMessage")
			data.title?.let { value ->
				StringEncoder.encode(value)?.let { map["title"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class UITooltipPlacement {
	TOP_CENTER,
	TOP_START,
	TOP_END,
	BOTTOM_CENTER,
	BOTTOM_START,
	BOTTOM_END,
	LEFT_CENTER,
	LEFT_START,
	LEFT_END,
	RIGHT_CENTER,
	RIGHT_START,
	RIGHT_END,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): UITooltipPlacement? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"TOP_CENTER" -> TOP_CENTER
				"TOP_START" -> TOP_START
				"TOP_END" -> TOP_END
				"BOTTOM_CENTER" -> BOTTOM_CENTER
				"BOTTOM_START" -> BOTTOM_START
				"BOTTOM_END" -> BOTTOM_END
				"LEFT_CENTER" -> LEFT_CENTER
				"LEFT_START" -> LEFT_START
				"LEFT_END" -> LEFT_END
				"RIGHT_CENTER" -> RIGHT_CENTER
				"RIGHT_START" -> RIGHT_START
				"RIGHT_END" -> RIGHT_END
				else -> UNKNOWN
			}
		}

		fun encode(data: UITooltipPlacement?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				TOP_CENTER -> JsonPrimitive("TOP_CENTER")
				TOP_START -> JsonPrimitive("TOP_START")
				TOP_END -> JsonPrimitive("TOP_END")
				BOTTOM_CENTER -> JsonPrimitive("BOTTOM_CENTER")
				BOTTOM_START -> JsonPrimitive("BOTTOM_START")
				BOTTOM_END -> JsonPrimitive("BOTTOM_END")
				LEFT_CENTER -> JsonPrimitive("LEFT_CENTER")
				LEFT_START -> JsonPrimitive("LEFT_START")
				LEFT_END -> JsonPrimitive("LEFT_END")
				RIGHT_CENTER -> JsonPrimitive("RIGHT_CENTER")
				RIGHT_START -> JsonPrimitive("RIGHT_START")
				RIGHT_END -> JsonPrimitive("RIGHT_END")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class UITooltipSize (
	val width: Int? = null,
	val height: Int? = null,
) {
	companion object {
		fun decode(element: JsonElement?): UITooltipSize? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return UITooltipSize(
				width = IntDecoder.decode(element.jsonObject["width"]),
				height = IntDecoder.decode(element.jsonObject["height"]),
			)
		}

		fun encode(data: UITooltipSize?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("UITooltipSize")
			data.width?.let { value ->
				IntEncoder.encode(value)?.let { map["width"] = it }
			}
			data.height?.let { value ->
				IntEncoder.encode(value)?.let { map["height"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class UITooltipTransitionTarget {
	ANCHOR,
	SCREEN,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): UITooltipTransitionTarget? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"ANCHOR" -> ANCHOR
				"SCREEN" -> SCREEN
				else -> UNKNOWN
			}
		}

		fun encode(data: UITooltipTransitionTarget?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				ANCHOR -> JsonPrimitive("ANCHOR")
				SCREEN -> JsonPrimitive("SCREEN")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class UserPropertyType {
	INTEGER,
	DOUBLE,
	STRING,
	TIMESTAMPZ,
	BOOLEAN,
	SEMVER,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): UserPropertyType? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"INTEGER" -> INTEGER
				"DOUBLE" -> DOUBLE
				"STRING" -> STRING
				"TIMESTAMPZ" -> TIMESTAMPZ
				"BOOLEAN" -> BOOLEAN
				"SEMVER" -> SEMVER
				else -> UNKNOWN
			}
		}

		fun encode(data: UserPropertyType?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				INTEGER -> JsonPrimitive("INTEGER")
				DOUBLE -> JsonPrimitive("DOUBLE")
				STRING -> JsonPrimitive("STRING")
				TIMESTAMPZ -> JsonPrimitive("TIMESTAMPZ")
				BOOLEAN -> JsonPrimitive("BOOLEAN")
				SEMVER -> JsonPrimitive("SEMVER")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal class VariantConfig (
	val key: String? = null,
	val kind: VariantConfigKind? = null,
	val value: String? = null,
) {
	companion object {
		fun decode(element: JsonElement?): VariantConfig? {
			if (element == null) {
				return null
			}
			if (element !is JsonObject) {
				return null
			}

			return VariantConfig(
				key = StringDecoder.decode(element.jsonObject["key"]),
				kind = VariantConfigKind.decode(element.jsonObject["kind"]),
				value = StringDecoder.decode(element.jsonObject["value"]),
			)
		}

		fun encode(data: VariantConfig?): JsonElement? {
			if (data == null) {
				return JsonNull
			}

			val map = mutableMapOf<String, JsonElement>()
			map["__typename"] = JsonPrimitive("VariantConfig")
			data.key?.let { value ->
				StringEncoder.encode(value)?.let { map["key"] = it }
			}
			data.kind?.let { value ->
				VariantConfigKind.encode(value)?.let { map["kind"] = it }
			}
			data.value?.let { value ->
				StringEncoder.encode(value)?.let { map["value"] = it }
			}

			return JsonObject(map)
		}
	}
}

internal enum class VariantConfigKind {
	COMPONENT,
	STRING,
	NUMBER,
	BOOLEAN,
	JSON,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): VariantConfigKind? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"COMPONENT" -> COMPONENT
				"STRING" -> STRING
				"NUMBER" -> NUMBER
				"BOOLEAN" -> BOOLEAN
				"JSON" -> JSON
				else -> UNKNOWN
			}
		}

		fun encode(data: VariantConfigKind?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				COMPONENT -> JsonPrimitive("COMPONENT")
				STRING -> JsonPrimitive("STRING")
				NUMBER -> JsonPrimitive("NUMBER")
				BOOLEAN -> JsonPrimitive("BOOLEAN")
				JSON -> JsonPrimitive("JSON")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}


internal enum class Weekdays {
	SUNDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	UNKNOWN,;

	companion object {
		fun decode(element: JsonElement?): Weekdays? {
			if (element == null) {
				return null
			}
			if (element !is JsonPrimitive) {
				return null
			}
			if (element is JsonNull) {
				return null
			}
			if (!element.jsonPrimitive.isString) {
				return null
			}
			return when (element.jsonPrimitive.content) {
				"SUNDAY" -> SUNDAY
				"MONDAY" -> MONDAY
				"TUESDAY" -> TUESDAY
				"WEDNESDAY" -> WEDNESDAY
				"THURSDAY" -> THURSDAY
				"FRIDAY" -> FRIDAY
				"SATURDAY" -> SATURDAY
				else -> UNKNOWN
			}
		}

		fun encode(data: Weekdays?): JsonElement? {
			if (data == null) {
				return JsonNull
			}
			return when (data) {
				SUNDAY -> JsonPrimitive("SUNDAY")
				MONDAY -> JsonPrimitive("MONDAY")
				TUESDAY -> JsonPrimitive("TUESDAY")
				WEDNESDAY -> JsonPrimitive("WEDNESDAY")
				THURSDAY -> JsonPrimitive("THURSDAY")
				FRIDAY -> JsonPrimitive("FRIDAY")
				SATURDAY -> JsonPrimitive("SATURDAY")
				UNKNOWN -> JsonPrimitive("UNKNOWN")
			}
		}
	}
}

